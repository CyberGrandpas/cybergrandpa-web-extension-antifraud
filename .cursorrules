# .cursorrules

You are an AI assistant helping with a cross-browser web extension project built with WXT framework and Svelte 5. Follow these rules and guidelines when working with this codebase.

## Core Directives

1. **Svelte 5 Only**: Always use Svelte 5 syntax with runes. Never suggest Svelte 4 solutions or syntax.
2. **Cross-browser Extension**: This is a web extension that must work across Chrome and Firefox using Manifest V3.
3. **No Formatting Suggestions**: Do not provide inline formatting suggestions - focus on functionality and architecture.
4. **Package Manager**: Always use `bun` for package management operations.

## Project Overview

This is an anti-fraud and safety web extension that blocks malicious URLs using a distributed blocklist system. The extension provides real-time URL blocking, cross-browser compatibility, and multi-language support.

## Technology Stack

- **Framework**: WXT (Web Extension Framework) with TypeScript
- **Frontend**: Svelte 5 with runes syntax
- **Styling**: SASS/SCSS with modular architecture
- **Database**: LokiJS for in-memory URL storage
- **Communication**: @webext-core/proxy-service for cross-context messaging
- **Internationalization**: @wxt-dev/i18n with YAML locale files

## Development Commands

### Building and Development

- `bun dev` - Start development server with hot reload
- `bun dev:firefox` - Start development server for Firefox
- `bun build` - Build extension for production
- `bun build:firefox` - Build extension for Firefox specifically
- `bun zip` - Create distribution ZIP file
- `bun zip:firefox` - Create Firefox distribution ZIP

### Code Quality

- `bun lint` - Run prettier check and ESLint
- `bun format` - Format code with Prettier
- `bun check` - Run Svelte type checking
- `bun check:watch` - Run Svelte type checking in watch mode

### Package Management

- Always use `bun` as the package manager
- Run `bun postinstall` after dependency changes to prepare WXT

## Architecture Guidelines

### Entrypoints Structure (`src/entrypoints/`)

- `background.ts` - Service worker for extension lifecycle, message passing, and URL blocking
- `content.ts` - Content script for page scanning and UI injection
- `close.content.ts` - Content script for closing/blocking tabs
- `popup/` - Extension popup interface
- `options/` - Extension settings page
- `wizard/` - Onboarding wizard for new users

### Core Services (`src/libs/`)

- `urls-service.ts` - URL blocklist management with compressed storage
- `web-blocking.ts` - Real-time URL blocking using webNavigation API
- `store.ts` - Persistent storage management
- `init-db.ts` - Database initialization and setup

### Component Architecture (`src/components/`)

- Use modular Svelte 5 components with consistent props interfaces
- Reusable components: Button, Modal, Toggle, Status, Header
- App-specific components go in `apps/` directory
- Icon components go in `icons/` directory
- Always use Svelte 5 runes syntax (`$state`, `$derived`, `$effect`, etc.)

### Utilities (`src/utils/`)

- Cross-context messaging utilities
- Tab management and activation
- Stream processing for compressed data
- Environment and configuration helpers

## Key Features to Maintain

- **URL Blocking**: Uses compressed blocklist from hblock.molinero.dev/hosts
- **Real-time Scanning**: Monitors navigation and blocks malicious URLs
- **Cross-browser Support**: Manifest V3 compatible with Chrome and Firefox
- **Internationalization**: Multi-language support (EN, DE, ES, FR, IT, NL, PT)
- **Onboarding**: Wizard-based setup for new users

## Browser Permissions

Required permissions:

- `activeTab`, `alarms`, `scripting`, `storage`, `tabs`
- `webNavigation`, `declarativeNetRequestWithHostAccess`
- `host_permissions` for all URLs

## Storage Strategy

- Use WXT storage API with local storage
- Compressed URL data using streams and base64 encoding
- Proxy service for cross-context data access
- Real-time updates across all contexts

## Internationalization

- YAML locale files in `src/locales/`
- Supports: English, German, Spanish, French, Italian, Dutch, Portuguese
- Messages accessed via `i18n.t()` function
- Manifest uses `__MSG_*__` format for localized strings

## Code Style Guidelines

- Use TypeScript with strict typing throughout
- Follow Svelte 5 runes syntax patterns
- Use SASS/SCSS with modular styling architecture
- Maintain consistent component prop interfaces
- Use PostCSS with rem-to-px conversion
- Follow ESLint configuration for TypeScript and Svelte

## Development Workflow

- Hot reload during development
- Browser-specific builds and testing
- Automatic manifest generation
- Type checking with Svelte compiler integration

When making changes:

1. Always use Svelte 5 syntax and patterns
2. Ensure cross-browser compatibility
3. Maintain TypeScript strict typing
4. Follow the established component architecture
5. Use the correct development commands with `bun`
6. Consider internationalization for user-facing text
7. Test both Chrome and Firefox builds when applicable

## Detailed Component Patterns

### Svelte 5 Component Structure

```svelte
<script lang="ts">
  import type { ComponentProps } from '@/utils';
  
  // Props with $props() rune
  let { prop1, prop2 = 'default' }: ComponentProps = $props();
  
  // State with $state() rune
  let localState = $state(initialValue);
  
  // Derived values with $derived() rune
  let computed = $derived(localState * 2);
  
  // Effects with $effect() rune
  $effect(() => {
    // Side effects here
    return () => {
      // Cleanup here
    };
  });
</script>

<!-- Template with Svelte 5 syntax -->
<div class="component">
  {@render children()}
</div>

<style lang="scss">
  .component {
    // SCSS styles with CSS variables
    color: var(--text-color-light);
  }
</style>
```

### Component Props Interface Pattern

Always define TypeScript interfaces for component props in `src/utils/types.ts`:

```typescript
export interface ComponentProps {
  prop1: string;
  prop2?: boolean;
  children?: Snippet;
  onClick?: () => void;
}
```

### Store Pattern

Use the custom `createStore` utility for persistent state:

```typescript
export const storeName = createStore<Type>(defaultValue, 'storage:key');
```

### Message Passing Pattern

Use the established message passing system:

```typescript
// Send messages
await sendMessage({ type: 'messageType', tabId: id });

// Handle messages in background/content scripts
browser.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.type === 'messageType') {
    // Handle message
    return true; // For async responses
  }
});
```

### URL Blocking Pattern

The extension uses a sophisticated URL blocking system:

1. **Background Script**: Monitors `webNavigation.onBeforeNavigate`
2. **URL Service**: Checks URLs against compressed blocklist
3. **Content Scripts**: Handle page blocking and user interaction
4. **Storage**: Compressed base64-encoded blocklist from external source

### Styling Guidelines

- Use CSS custom properties (variables) defined in `src/styles/style.scss`
- Follow the modular SCSS architecture with numbered files
- Use `rem` units with PostCSS conversion to pixels
- Maintain consistent spacing and color schemes
- Support both light and dark themes

### Internationalization Pattern

```typescript
// In components
let t = i18n.t;

// Usage
{t('key.subkey')}
{t('key.withParams', [param1, param2])}
```

### Error Handling

- Use try-catch blocks for async operations
- Log errors with `console.error()` for debugging
- Gracefully handle storage and network failures
- Provide user feedback for critical operations

### Performance Considerations

- Use compressed data for large datasets (URL blocklist)
- Implement efficient filtering and searching algorithms
- Minimize content script injection overhead
- Use proper cleanup in effects and event listeners

### Security Guidelines

- Validate all external data sources
- Use Content Security Policy appropriately
- Sanitize user inputs and external URLs
- Follow browser extension security best practices
- Implement proper permission scoping

### Testing Strategy

- Test both Chrome and Firefox builds
- Verify cross-context communication
- Test URL blocking functionality
- Validate internationalization
- Check storage persistence
- Test onboarding flow

### Common Patterns to Follow

1. **Component Composition**: Use slots/children for flexible component design
2. **State Management**: Prefer reactive stores over local state when data needs persistence
3. **Event Handling**: Use proper cleanup in effects and event listeners
4. **Type Safety**: Always define interfaces for complex data structures
5. **Error Boundaries**: Implement proper error handling for async operations
6. **Accessibility**: Use proper ARIA labels and semantic HTML
7. **Performance**: Minimize re-renders and optimize bundle size
